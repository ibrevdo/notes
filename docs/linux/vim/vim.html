
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=1">
    <title>Igor's notes: Vim</title>
    <link rel="stylesheet" href="https://ibrevdo.github.io/notes/css/common.css">
</head>

<body>

<div id="navbar">
    <ul>
    <li><a  href="/index.html">Home</a></li>
    <li><a  href="/linux/index.html">Linux</a></li>
    <li><a  href="/programming/index.html">Programming</a></li>
    <li><a  href="/computing/index.html">Computing</a></li>
    <li><a  href="/studies/index.html">Studies</a></li>
    <li><a  href="/webtools/webtools.html">Webtools</a></li>
    <li><a  href="/travel/index.html">Travel</a></li>
    <li><a  href="/media/index.html">Media</a></li>
    <li><a  href="/etc/index.html">Etc</a></li>
    </ul>
</div>

<div class="toc">
<ul>
<li><a href="#vim">Vim</a><ul>
<li><a href="#movement">Movement</a></li>
<li><a href="#scroll">Scroll</a></li>
<li><a href="#operations">Operations</a></li>
<li><a href="#searching">Searching</a></li>
<li><a href="#marks">Marks</a></li>
<li><a href="#registers">Registers</a></li>
<li><a href="#macros">Macros</a></li>
<li><a href="#insert-mode">Insert mode</a></li>
<li><a href="#insert-completion-mode">Insert completion mode</a></li>
<li><a href="#windows">Windows</a></li>
<li><a href="#visual-mode">Visual mode</a></li>
<li><a href="#command-line-mode">Command-line mode</a></li>
<li><a href="#general-commands">General commands</a></li>
<li><a href="#arglist">Arglist</a></li>
<li><a href="#quickfix-list">Quickfix list</a></li>
<li><a href="#tags">Tags</a></li>
<li><a href="#finding-file">Finding file</a></li>
<li><a href="#folding">Folding</a></li>
<li><a href="#vimdiff">Vimdiff</a></li>
<li><a href="#clipboard">Clipboard</a></li>
<li><a href="#search-substitute-and-vim-regex">Search, substitute and vim regex</a><ul>
<li><a href="#global-command">Global command</a></li>
<li><a href="#vimgrep">vimgrep</a></li>
<li><a href="#grep">grep</a></li>
</ul>
</li>
<li><a href="#netrw-commands">netrw commands</a></li>
<li><a href="#useful-settings">Useful settings</a></li>
<li><a href="#tips">Tips</a></li>
</ul>
</li>
</ul>
</div>



<div class="content">
    <div class="folder">
        <p>&#60;linux/vim&#62;</p>    
    </div>
    <h1 id="vim">Vim</h1>
<hr />
<h2 id="movement">Movement</h2>
<p>Jumps commands include: searches (and repetitions), substitutions, parenthesses jumping,
paragraphs and sentences, locations inside window, opening another file</p>
<ul>
<li><code>w</code>/<code>W</code>           move to start of next word/WORD (the delimeter of WORD is space)</li>
<li><code>b</code>/<code>B</code>           move back to start of previous word/WORD</li>
<li><code>e</code>/<code>E</code>           move to end of next word/WORD</li>
<li><code>ge</code>/<code>gE</code>         move back to end of previous word/WORD</li>
<li><code>0</code>/<code>$</code>           move to start/end of line</li>
<li><code>f&lt;char&gt;</code>/<code>F&lt;ch&gt;</code> move forward/back to next occurance of letter <code>&lt;char&gt;</code></li>
<li><code>t&lt;char&gt;</code>/<code>T&lt;ch&gt;</code> move until next occurance of letter <code>&lt;char&gt;</code></li>
<li><code>;</code>               repeat above, in same direction</li>
<li><code>,</code>               repeat above, in reverse direction</li>
<li><code>(</code>/<code>)</code>           jump to prev/next sentence</li>
<li><code>{</code>/<code>}</code>           jump to prev/next paragraph</li>
<li><code>[[</code>/<code>]]</code>         jump to prev/next code block (first column has <code>{</code>)</li>
<li><code>gg</code>/<code>G</code>          jump to start/end of file</li>
<li><code>H</code>/<code>M</code>/<code>L</code>       jump to windows top/middle/bottom</li>
<li><code>&lt;C-d&gt;</code>, <code>&lt;C-u&gt;</code>  half page down/up</li>
<li><code>&lt;C-f&gt;</code>, <code>&lt;C-b&gt;</code>  page forward, page back</li>
<li><code>%</code>               jump to matching bracket <code>( ), [ ], { }</code>. Even if the cursor is not positioned on the bracket</li>
<li><code>''</code>              jump back to line where cursor was before the latest jump</li>
<li><code>'.</code>              jump to line where was last change</li>
<li><code>:jumps</code>          see list of jumps</li>
<li><code>g;</code> <code>g,</code>         go back/forward through list of changes (<code>:changes</code> see list of changes)</li>
<li><code>C-i</code>             jump forward (in)</li>
<li><code>C-o</code>             jump back (out)</li>
<li><code>C-]</code>             jump to tag definition (works in help or with ctags)</li>
<li><code>C-T</code>             jump back from C-] jump</li>
<li><code>gf</code>              jump to file under cursor                     </li>
<li><code>gd</code>/<code>gD</code>         jump to definition(first occurance)/global definition of word under cursor</li>
</ul>
<h2 id="scroll">Scroll</h2>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>zz</td>
<td>scroll the line with the cursor to the center of the screen</td>
</tr>
<tr>
<td>zt</td>
<td>scroll the line with the cursor to the top</td>
</tr>
<tr>
<td>zb</td>
<td>scroll the line with the cursor to the bottom</td>
</tr>
<tr>
<td>C-y</td>
<td>scroll up</td>
</tr>
<tr>
<td>C-e</td>
<td>scroll down</td>
</tr>
</tbody>
</table>
<h2 id="operations">Operations</h2>
<ul>
<li><code>i</code>           enter insert mode before cursor pos</li>
<li><code>a</code>           enter insert mode after cursor pos</li>
<li><code>I</code>           enter insert mode at the start of the line</li>
<li><code>A</code>           enter insert mode at the end of the line</li>
<li><code>o</code>,<code>O</code>       enter new line after/before current and stay in insert mode</li>
<li><code>x</code>,<code>X</code>       delete single character at/before cursor position</li>
<li><code>r</code>           replace single character at cursor position</li>
<li><code>R</code>           enter replace mode</li>
<li><code>["x]d{motion}</code>   delete from cursor pos till the "motion" [put deleted text into register x]</li>
<li>examples:<ul>
<li><code>dw</code>      delete till the start of next word</li>
<li><code>dt}</code>     delete till next occurance of }</li>
<li><code>dd</code>      delete whole line</li>
<li><code>D</code>       delete from cursor pos till end of line</li>
</ul>
</li>
<li><code>["x]c{motion}</code>   change from cursor pos till the "motion" [put deleted text into register x]. (like delete but stay in insert mode)</li>
<li><code>["x]y{motion}</code>   yank (copy) from cursor pos till the "motion" [put yanked text into register x]</li>
<li><code>["x]p</code>,<code>["x]P</code>   paste yanked/deleted text after/before the cursor pos [take a text from register x]</li>
</ul>
<h2 id="searching">Searching</h2>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>find (and highlight) exact word under cursor (forward)</td>
</tr>
<tr>
<td><code>#</code></td>
<td>find (and highlight) exact word under cursor (backwards)</td>
</tr>
<tr>
<td><code>g*</code></td>
<td>find (and highlight) partial word under cursor (forward)</td>
</tr>
<tr>
<td><code>g#</code></td>
<td>find (and highlight) partial word under cursor (backwards)</td>
</tr>
<tr>
<td><code>/text</code></td>
<td>find text (forward)</td>
</tr>
<tr>
<td><code>?text</code></td>
<td>find text (backward)</td>
</tr>
<tr>
<td><code>n</code></td>
<td>next matching search pattern</td>
</tr>
<tr>
<td><code>N</code></td>
<td>previous matching search pattern</td>
</tr>
</tbody>
</table>
<h2 id="marks">Marks</h2>
<pre><code>|               |                                                              |
| ------------- | ---------------------------------------------------------    |
| Auto marks    |                                                              |
| ``            | last jump (cursor pos) within current file                   |
| `.            | last edit (cursor pos) within current file                   |
| `0            | jump to position in last file edited (after exiting vim)     |
| `[ `]         | start/end of last changed or yanked text                     |
| `&lt; `&gt;         | start/end of last visual selelction                          |
| 'a            | go to line of mark a                                         |
| `a            | go to cursor position of mark a                              |
| Local marks   |                                                              |
| ma            | put current postion in mark a                                |
| Global marks  | Global marks use capital letters and are saved between files |
| mA            | set global mark by m and capital letter                      |
</code></pre>

<h2 id="registers">Registers</h2>
<ul>
<li>The command that can use a register looks like this : <code>"{register}command</code>.</li>
<li>For example, to a yank a current word into register 'a' run : <code>"ayiw</code></li>
<li>To yank a selected word into register b: 1) select a word 2) <code>"by</code></li>
<li>To paste from register a: <code>"ap</code></li>
<li>To paste from a default register while in insert mode: <code>&lt;C-r&gt;"</code></li>
<li>To copy one register to another : <code>let @b=@a</code></li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>""</code></td>
<td>unnamed (default) register. contains what was deleted/yanked.</td>
</tr>
<tr>
<td></td>
<td>Commands <code>x</code>,<code>s</code>,<code>c{motion}</code>,<code>d{motion}</code> all set content of this register</td>
</tr>
<tr>
<td><code>"0</code></td>
<td>yank register. command <code>y{motion}</code> sets this register</td>
</tr>
<tr>
<td><code>"0p</code></td>
<td>paste from yank register</td>
</tr>
<tr>
<td><code>:reg</code></td>
<td>inspect registers</td>
</tr>
<tr>
<td><code>"a</code></td>
<td>named register a</td>
</tr>
<tr>
<td><code>"/</code></td>
<td>last search register</td>
</tr>
<tr>
<td><code>":</code></td>
<td>last Ex command</td>
</tr>
<tr>
<td><code>"%</code></td>
<td>name of current file</td>
</tr>
<tr>
<td><code>&lt;C-r&gt;</code></td>
<td>Use register in insert mode/command mode</td>
</tr>
<tr>
<td><code>&lt;C-r&gt;&lt;C-w&gt;</code></td>
<td>Put word under cursor in command mode</td>
</tr>
</tbody>
</table>
<h2 id="macros">Macros</h2>
<ul>
<li><code>qa</code>      Start recording macro into register a. Stop recroding with <code>q</code>. </li>
<li><code>@a</code>      play macro stored in register a</li>
<li><code>@@</code>      repeat last executed macro</li>
<li><code>22@a</code>    execute macro on next 22 buffers (num of buffers can be less than 22)</li>
<li><code>:%norm! @a</code>  To repeat macro stored in register 'a', on whole file: </li>
</ul>
<h2 id="insert-mode">Insert mode</h2>
<ul>
<li><code>C-a</code> paste last inserted text</li>
<li><code>C-o</code> execute single normal mode command</li>
<li><code>C-[</code> go to normal mode</li>
<li><code>C-w</code> delete word before the cursor</li>
<li><code>C-u</code> delete current line</li>
<li><code>C-r</code> paste from register</li>
<li><code>C-r "</code> insert the last yank/delete</li>
<li><code>C-r %</code> insert file name</li>
<li><code>C-r /</code> insert last search item</li>
<li><code>C-r :</code> insert last command</li>
<li><code>C-x C-y</code> scroll up</li>
<li><code>C-x C-e</code> scroll down</li>
</ul>
<h2 id="insert-completion-mode">Insert completion mode</h2>
<ul>
<li>This is a sub mode of insert mode. You can enter it by typing <code>C-x</code> and one of <code>C-x</code> commands while in insert mode.</li>
<li>While in completion mode, use <code>C-n</code>/<code>C-p</code> to choose next/previous sugestion.</li>
<li>When completion is active you can use <code>C-y</code> to accept currently selected entry.</li>
<li>Or you can use <code>C-e</code> to end the completion and go back to original text.</li>
<li><code>C-n</code>/<code>C-p</code> "complete any word" complete keyword under cursor according to <code>complete</code> option.<ul>
<li><code>.,w,b,u,t,i</code> complete order: current buffer, open windows, loaded buffers, tags, included files</li>
</ul>
</li>
<li><code>C-x C-u</code> "user defined completion" complete according to a function specified in <code>completefunc</code> option</li>
<li><code>C-x C-f</code> complete a filename (the filenames are searched according to <code>path</code> option)</li>
<li><code>C-x C-]</code> complete from tags</li>
<li><code>C-x C-o</code> "omni completion" complete according to a function specified in <code>omnifunc</code> option<ul>
<li><code>C</code> requires a tags file. Example: <code>% ctags -R -f ~/.vim/systags /usr/include</code> </li>
<li>add the file to <code>tags</code> option: <code>set tags+=~/.vim/systags</code></li>
<li>When omni completion is used after "." or "-&gt;", it attempts to recognize the type of variable and suggest only valid members.</li>
</ul>
</li>
<li><code>C-x C-l</code> complete whole lines</li>
<li><code>C-x C-n</code> complete word from current buffer (search next)</li>
<li><code>C-x C-p</code> complete word from current buffer (search previous)</li>
<li><code>C-x C-i</code> complete from included files (the files are search according to <code>path</code> option</li>
<li><code>C-x C-d</code> complete definitions and macros. from included files (the files are search according to <code>path</code> option</li>
<li><code>C-x C-k</code> complete from dictionary. Uses a list of words from <code>dictionary</code> option</li>
<li><code>C-x C-s</code> complete with spelling suggestion (Possible to use <code>C-x s</code> because <code>C-s</code> suspends display in many terminals. Use <code>C-q</code> to unsuspend)</li>
</ul>
<h2 id="windows">Windows</h2>
<p>All window commands can be activated with <code>&lt;C-w&gt;&lt;C-&lt;letter&gt;&gt;</code> or just <code>&lt;C-w&lt;letter&gt;&gt;</code></p>
<ul>
<li><code>:sp &lt;file&gt;</code>      split and load file into new window</li>
<li><code>:sb #</code>           split other buffer to window</li>
<li><code>:new</code>,<code>:vnew</code>    split and open new buffer</li>
<li><code>:close</code>,<code>C-wq</code>,<code>:q</code>  close current window</li>
<li><code>:only</code>,<code>C-wo</code>    close other windows</li>
<li><code>C-ws</code>            split current window vertically </li>
<li><code>C-wf</code>            edit file under cursor in a split window</li>
<li><code>C-ww</code>            go to window below/right of current one</li>
<li><code>C-w&lt;arrow&gt;</code>      go to window according to direction</li>
<li><code>C-wp</code>            go to previous window</li>
<li><code>C-wq</code>            close current window</li>
<li><code>C-w+</code> <code>C-w-</code>     increase/decrease current window</li>
<li><code>C-w&gt;</code> <code>C-w&lt;</code>     increase/decrease width</li>
<li><code>C-w_</code>            set current window height to maximum</li>
<li><code>C-|</code>             set current window width to maximum</li>
<li><code>C-w=</code>            make all windows even size</li>
<li><code>C-w K/J/H/L</code>     move current window to top/bottom/left/right</li>
<li><code>C-wr</code>            rotate windows locations</li>
<li><code>C-wx</code>            exchange locations of two neighbor windows</li>
<li><code>C-wz</code>            close preview window</li>
</ul>
<h2 id="visual-mode">Visual mode</h2>
<ul>
<li><code>o</code>   - move to other end of marked area</li>
<li><code>gv</code>  reselect last visual selection</li>
<li>highlight text objects<ol>
<li><code>vi}</code>    highlight inner {} block</li>
<li><code>va)</code>    highlight outer () block</li>
</ol>
</li>
</ul>
<h2 id="command-line-mode">Command-line mode</h2>
<ul>
<li><code>C-b</code> begining of command line</li>
<li><code>C-e</code> end of command line</li>
<li><code>C-w</code> delete the word before cursor</li>
<li><code>C-u</code> delete everything between cursor and begining of line</li>
<li><code>C-v</code> enter special character. For example: pressing C-x results ^X. Is used when editing macros stored in registers</li>
<li><code>q:</code> <code>:&lt;C-f&gt;</code> open buffer of command line</li>
<li><code>q/</code>/<code>q?</code> open cmdline for search/backward</li>
<li><code>C-c</code> exit the window</li>
<li><code>@:</code>  repeate last Ex command</li>
</ul>
<hr />
<h2 id="general-commands">General commands</h2>
<ul>
<li><code>&lt;C-l&gt;</code>   redraw screen</li>
<li><code>&lt;C-g&gt;</code>   Shows filename, current line number, total lines in file, and % of file location</li>
<li><code>&lt;S-r&gt;</code>   Enter REPLACE mode</li>
<li><code>&lt;S-q&gt;</code>   Enter Ex mode</li>
<li><code>=G</code>      indent till end of file</li>
<li><code>J</code>       join a line bellow to current line</li>
<li><code>gJ</code>      join a line bellow to current line (without space)</li>
<li><code>gv</code>      reselect last visual selection</li>
</ul>
<h2 id="arglist">Arglist</h2>
<ul>
<li><code>:args</code>           show arglist</li>
<li>populate args with shell command</li>
</ul>
<pre><code class="sh">    :args `find *.md`
</code></pre>

<ul>
<li><code>:next</code>/<code>:prev</code>   traverse trough buffers inside arglsist</li>
<li><code>:first</code>/<code>:last</code>  jump to first/last buffer of arglist</li>
<li><code>:argdo %s/\a/*/ge</code> execute substitude command on every file in arglist</li>
<li><code>:argdo edit!</code>    undo last change in all buffers in arglist</li>
<li><code>:argdo update</code>    save changes in all buffers in arglist</li>
<li><code>:argdo normal @a</code> execute macro on every file in arg list</li>
</ul>
<h2 id="quickfix-list">Quickfix list</h2>
<ul>
<li><code>:copen</code>,<code>:close</code> open/close quickfix window</li>
<li><code>:ccl</code>            close quickfix window</li>
<li><code>:cw</code>             open if there are results / close it otherwise</li>
<li><code>:cc [nr]</code>        go to result number (go to same result if number omitted)</li>
<li><code>:cp</code>,<code>[q</code>        show prev entry of quickfix list</li>
<li><code>:cn</code>,<code>]q</code>        show next entry of quickfix list</li>
<li><code>:cfirst</code>,<code>[Q</code>    show first entry of quickfix list</li>
<li><code>:clast</code>,<code>]Q</code>     show last entry of quickfix list</li>
</ul>
<h2 id="tags">Tags</h2>
<ul>
<li><code>C-]</code>             jump to tag definition</li>
<li><code>C-w]</code>            open tag definition in split windiw</li>
<li><code>C-w }</code>           open tag definition in preview window</li>
<li><code>pc</code>              preview close</li>
<li><code>C-wz</code>            preview close</li>
<li><code>g]</code>              open a window of defintions of current tag</li>
<li><code>tj &lt;expr&gt;</code>       open a window of definitions of tag <code>&lt;expr&gt;</code></li>
<li><code>ptj &lt;expr&gt;</code>      open a preview window for tag <code>&lt;expr&gt;</code>. Use <code>ptn</code>, <code>ptp</code> to navigate</li>
<li><code>:tag /&lt;expr&gt;</code>    search for tag</li>
</ul>
<h2 id="finding-file">Finding file</h2>
<p><code>edit</code> and <code>find</code> commands are used to find and open an paritcular file.</p>
<ul>
<li><code>:e[dit]</code>  command to open files relatively to working directory.
            Supports globs use. Example:</li>
<li><code>:e **/*time&lt;Tab&gt;</code>   find recursively file with partial name "time" and open it</li>
<li><code>:fin[d]</code> command is used to open files relatively to <code>path</code> locations.</li>
<li><code>:set path?</code>  to inspect current path locations</li>
<li>if <code>**</code> is added to path, then is is possible to use find like that:</li>
<li><code>:fin *time&lt;Tab&gt;</code> to search for partial name recursively</li>
</ul>
<h2 id="folding">Folding</h2>
<ul>
<li><code>zf{moion}</code>       create fold</li>
<li><code>zfa{</code>            create fold of a paragraph between curly braces ( a function block)</li>
<li><code>zd</code>              fold delete</li>
<li><code>zE</code>              folds eliminate (delete all folds in the document)</li>
<li><code>zo</code>/<code>zc</code>         open/close current fold</li>
<li><code>zO</code>/<code>zC</code>         open/close current and nested folds</li>
<li><code>za</code>              toggle open/close for current fold </li>
<li><code>zA</code>              toggle open/close for current and nested folds </li>
<li><code>zr</code>              reveal all folds one level</li>
<li><code>zR</code>              reveal all folds completely</li>
<li><code>zm</code>              fold more on all folds</li>
<li><code>zM</code>              fold completely all folds</li>
<li><code>zn</code>              folds none (open all folds in file)</li>
<li><code>zN</code>              folds normal (return prevoius folding)  </li>
<li><code>zi</code>              switch folding on/off</li>
<li><code>zv</code>              expand folds to reveal cursor</li>
<li><code>[z</code>,<code>]z</code>         go to start/end of current fold</li>
<li><code>zj</code>,<code>zk</code>         go to next/previous fold</li>
<li><code>:mkview</code>         save created folds</li>
<li><code>:loadview</code>       load previously created folds</li>
</ul>
<h2 id="vimdiff">Vimdiff</h2>
<p>Open two windows with two buffers (each buffer may be unnamed)</p>
<ul>
<li><code>:windo diffthis</code> start diff on two windows</li>
<li><code>:windo diffoff</code>  stop diff</li>
<li><code>[c</code>,<code>]c</code>     jump back and forward between changes</li>
<li><code>:diffget</code>,<code>:diffput</code> resolve differences between files</li>
<li><code>:diffupdate</code> rescan changes</li>
</ul>
<h2 id="clipboard">Clipboard</h2>
<ul>
<li>In Linux (X11) there two types of clipboards:<ul>
<li>Selection (<code>"*</code>) - populated by selection. Paste with middle mouse.</li>
<li>Clipboard (<code>"+</code>) - populated with CTRL-C. Paste with CTRL-V or right mouse option.</li>
<li>In Windows only clipboard exists, so both registers have same values</li>
</ul>
</li>
<li>In order to use the registers Vim needs to have <code>+clipboard</code> enabled (check it with <code>:echo has('clipboard')</code>.<ul>
<li>'clipboard' is usually enabled in gvim (vim-gtk in Ubuntu) and not enabled in terminal vim</li>
<li><code>"+y</code> puts visual selection from Vim into system clipboard (paste it with CTRL-V)</li>
<li><code>"+p</code> puts CTR-C text from system into Vim</li>
</ul>
</li>
<li>Otherwise you can use terminal copy/paste capability:<ul>
<li>In order to copy to clipboard from vim hold "Shift" while selecting with mouse. Now paste qith middle button</li>
<li>In order to paste form clipboard into vim use "shift+middle click" or "Shift+Insert"</li>
</ul>
</li>
</ul>
<hr />
<h2 id="search-substitute-and-vim-regex">Search, substitute and vim regex</h2>
<p>Search with <code>/&lt;expr&gt;</code>, substitute with <code>range s/pattern/string/cgiIe</code>. \
Where c-confirm, g-all occurances in range, i-ignore case, I-don't ignore case, e-don't show errors
It is possible to use any character instead of <code>/</code> as a separator.</p>
<ul>
<li><code>\&lt;</code>,<code>\&gt;</code> Anchors for start and end of a word. Example: <code>/\&lt;i\&gt;</code> search for a word i</li>
<li><code>^</code>, <code>$</code>  Anchors for begining and end of a line. </li>
<li><code>.</code>       any character except a new line</li>
<li><code>\s</code>,<code>\d</code>,<code>\w</code>,<code>\a</code> Space character, digit, word, alphabetic</li>
<li><code>\S</code>,<code>\D</code>,<code>\W</code>,<code>\A</code> Non-Space character, Non-digit, Non-word, Non-alphabetic</li>
<li><code>*</code>           matches 0 or more characters. <code>.*</code> matches everything.</li>
<li><code>\+</code>          matches 1 or more.</li>
<li><code>\=</code>          matches 0 or 1</li>
<li><code>{n}</code>,<code>{,m}</code>,<code>{n,}</code>,<code>{n,m}</code> matches exactly n, 0 to m, at least n, from n to m.</li>
<li><code>[012345]</code>    character range will match any of characters inside</li>
<li><code>[^A-Z]</code>      Negation sign <code>^</code> will match any character which is not in a range</li>
<li><code>\(</code>, <code>\)</code>     group part of pattern and refer to them inside replacement pattern by their
                number <code>\1</code>,<code>\2</code>,<code>\3</code></li>
<li><code>\|</code>      Find this or that. The first match will be used. Not greedy. (so order is important)</li>
<li></li>
<li>Examples: </li>
<li><code>:s//str/</code>    use a prevoius expression again</li>
<li><code>%s:^vi$:VIM:g</code> Substitute all lines in a file that contain vi to VIM.</li>
<li><code>/\.\s+[a-z]</code> Find all places where new sentence doesn't start with capital letter. 
                a period followed by one or more blanks and a lowercase letter</li>
<li><code>%s:\([.!?]\)\s\+\([a-z]\):\1  \u\2:g</code> Correct the prevoius example. 
                                         Insert two spaces exactly between sentences.</li>
<li><code>\(Date:\|Subject:\|From:\)\(\s.*\)</code>  Parse various mail headings and their contents into
                                        <code>\1</code> and <code>\2</code>.</li>
<li>Useful mappings for substitutions</li>
</ul>
<pre><code class="sh">noremap ;; :%s:::gc&lt;Left&gt;&lt;Left&gt;&lt;Left&gt;
cmap    ;\ \(\)&lt;Left&gt;&lt;Left&gt;
</code></pre>

<h3 id="global-command">Global command</h3>
<p><code>:range g!/patern/cmd</code> Execute the Ex command (default: <code>:p</code>) on the lines within range 
where pattern matches. (or, if <code>!</code> is used, only where match does not occure) \
If range is not specified then operate on whole file</p>
<ul>
<li><code>:g/^$/ d</code>    delete all empty lines in a file</li>
<li><code>:g/^$/,/./-j</code> reduce multiple blank lines to a single blank</li>
<li><code>:g/^Error/ . w &gt;&gt; errors.txt</code> Find all lines starting with error and append them to errors.txt</li>
<li><code>:g/ml/s/:e/:sp/</code> substitute <code>:e</code> with <code>:sp</code> for each line that contains "ml"</li>
<li><code>:g//cmd</code>     use previous expression again</li>
</ul>
<h3 id="vimgrep">vimgrep</h3>
<p>vimgrep - use it to search in small group of files (like a local project)</p>
<ul>
<li><code>:vim[grep][!] /{pattern}/[g][j] {file} ...</code>  Full command (possible to use shell commands to populate files list. g-every match is added. j-dont jump on first match</li>
<li><code>:vim /expr/ %</code>       Search in current file</li>
<li><code>:vim /expr/ *</code>       Search in all files in current dir</li>
<li><code>:vim /expr/ *.cpp</code>   Search in multiple cpp files in current dir</li>
<li><code>:vim /expr/ **</code>      Search recursivly in all files (under the path)</li>
<li><code>:vim /expr/ **/*.h</code>    Search recursivly in all header files</li>
<li><code>:vim /expr/ ##</code>      search inside files in arglist</li>
</ul>
<p>search for last pattern
* press <code>*</code> on a word (will enter it to last search)
* Use empty pattern <code>:vim // **</code> to search it in all files recursively </p>
<p>search for all lines containing "dostuff()" in all .c files</p>
<ul>
<li><code>:vim /dostuff()/j ../**/*.c</code></li>
</ul>
<p>search inside hidden files</p>
<ul>
<li><code>:vimgrep /pattern/ ./.*</code></li>
</ul>
<h3 id="grep">grep</h3>
<p>grep - use on large amounts of files</p>
<ul>
<li>Search in all files in current dir : <code>:grep /expr/ *</code></li>
<li>Or search recursivly : <code>:grep -R /expr/ *</code></li>
<li><code>:grep -R pattern *.c</code></li>
<li><code>map &lt;F3&gt; :execute " grep -srnw --binary-files=without-match --exclude-dir=.git --exclude-from=exclude.list . -e " . expand("&lt;cword&gt;") . " " &lt;bar&gt; cwindow&lt;CR&gt;</code></li>
<li>you can fill file exclude.list with file patterns to exclude from search, such as <code>*~</code> – all files ending in a '~' character</li>
</ul>
<p>"grep" and "vimgrep" fill the "quickfix list", which can be opened with :cw or :copen, and is a list shared between ALL windows.</p>
<hr />
<h2 id="netrw-commands">netrw commands</h2>
<ul>
<li><code>:e .</code>    go to file system view of current directory</li>
<li><code>:Vex</code>    open explorer verticaly</li>
<li><code>o</code>       open file in a split</li>
<li><code>p</code>       preview file. (open in split)</li>
<li><code>S-p</code>     open file in previous window</li>
<li><code>-</code>       go up one directory</li>
<li><code>%</code>       create a new file</li>
<li><code>d</code>       make a directory</li>
<li><code>&lt;del&gt;</code>   remove file/directory</li>
<li><code>S-d</code>     remove direcory</li>
<li><code>s</code>       select sorting style</li>
<li><code>i</code>       toggle files details/structure views</li>
<li><code>I</code>       toggle help view</li>
<li><code>gh</code>      show/hide dot files</li>
<li><code>mb</code>      bookmark current dir</li>
<li><code>gb</code>      go to previously bookmarked directory</li>
<li><code>u</code>       change to recently visited directory</li>
</ul>
<h2 id="useful-settings">Useful settings</h2>
<ul>
<li>set completeopt=menuone,noinsert</li>
<li>set autoindent</li>
<li>set ft=xml</li>
<li>set relativenumber</li>
</ul>
<h2 id="tips">Tips</h2>
<ul>
<li><code>enew</code>,<code>new</code>,<code>vnew</code>    open a new unnamed buffer (current window, split horisontally, split vertically)</li>
<li><code>gd</code>      jump to first occurance of a word under cursor</li>
<li><code>gn</code>      go to next search result and visual highlight it</li>
<li><code>gu</code>/<code>gU</code> everything to lowercase/uppercase</li>
<li>switch between two chars: cursor on the first one, and then <code>xp</code></li>
<li>switch between two lines: cursor of first one, and then <code>ddp</code></li>
<li><code>v$r*</code>    replace till end of line with <code>*</code></li>
<li><code>i</code>   Operator 'i' works to operate on inner block. <ul>
<li><code>yiw</code> copy inner word (block=word)</li>
<li><code>di"</code> delete in quotes (block in between quotes)</li>
<li><code>ci{</code> change in curly braces (block is between curly braces)</li>
<li><code>dip</code> delete in paragraph (lines together)</li>
<li><code>cit</code> change inside tags (for example html tags)</li>
<li><code>&gt;iB</code> indent inner block</li>
</ul>
</li>
<li><code>a</code>       Operator 'a' can do the same but operates on 'outer' block</li>
<li><code>]p</code>      Paste and auto-indent</li>
<li><code>:9t.</code>    copy line 9 to cursor position</li>
<li><code>:so %</code>   treat temp file as vimrc, source it so configuration become active</li>
<li><code>:r!ls</code>   Add output of shell command into current buffer </li>
<li><code>:%!ls</code>   Fill current buffer with output of the shell command</li>
<li><code>:.!seq 0 255 | printf '\%02x' | fmt -w 50</code>   put a result of compex command instead of current line</li>
<li><code>:w !bash</code>    run lines of cuurent buffer on external command (bash)</li>
<li><code>!./%</code>    execute current buffer with shell (a buffer must be saved as a file and set as executable)</li>
<li><code>!!</code>      repeate the last shell command</li>
<li>
<p><code>.!!</code>     write the result of last shell command in current line</p>
</li>
<li>
<p>Comment multiple lines</p>
<ol>
<li>Position a cursor at start of line where comment required</li>
<li><code>C-v</code> to enter to visual block and go down as needed</li>
<li><code>I</code> to enter insert mode, enter the comment <code>#</code> and ESC to normal mode</li>
<li>to uncomment, do the same but instead entering insert mode, just press <code>x</code> to remove comments</li>
</ol>
</li>
<li>
<p>Delete blank lines</p>
<ul>
<li><code>g/^$/d</code></li>
<li><code>:g</code>  will execute a command on lines which match a regex. 
        The regex is 'blank line' and the command is <code>:d</code> (delete)</li>
</ul>
</li>
<li>
<p>Delete all buffers except current</p>
<ul>
<li><code>:%bd|e#</code> %bd = delete all buffers. e# = open the last buffer for editing.</li>
<li><code>command! BufOnly silent! execute "%bd|e#|bd#"</code></li>
</ul>
</li>
<li>
<p>Save file as a root</p>
<ul>
<li><code>w !sudo tee % &gt; /dev/null</code>   put a content of current buffer into <code>%</code> (current file) using sudo</li>
</ul>
</li>
<li>
<p>Find and replace in project wide</p>
<ol>
<li>Put all files of the project in arglist <code>:args *.cpp</code></li>
<li>Find all reqiured changes in the project <code>:vimgrep /expr/g ##</code></li>
<li>Qargs command puts all files from quicklist into arglist</li>
<li>Substitude in all files <code>argdo %s/expr/str/ge</code></li>
<li>Save all files <code>:argdo w</code></li>
</ol>
</li>
<li>
<p>Switch between .c and .h file</p>
<ul>
<li>switch from header to c : <code>:e %:r.cpp</code> and vice versa <code>:e %:r.h</code></li>
<li><code>map &lt;F4&gt; :e %:p:s,.h$,.X123X,:s,.cpp$,.h,:s,.X123X$,.cpp,&lt;CR&gt;</code></li>
</ul>
</li>
</ul>
</div>

<div id="path">
    ~/git/notes/md/linux/vim/vim.md
</div>

</body>
</html> 
